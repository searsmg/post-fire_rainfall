---
title: "Stage response analysis"
author: "Megan Sears"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: yes
    theme: journal
editor_options:
  chunk_output_type: console
---

```{r, include = F}

knitr::opts_chunk$set(echo = F,
                      message = F,
                      fig.width = 12,
                      fig.height = 6)

library(tidyverse)
library(plotly)
library(here)
library(ggplot2); theme_set(theme_bw(base_size = 20,
                                     base_family = "Arial"))
library(broom)
library(multcompView)
library(ggcorrplot)
library(cowplot)
library(reshape2)
library(lme4)
library(randomForest)
library(boot)
library(MuMIn) 
library(magrittr)

```

# Inputs

```{r}

# # this is only for events > 5 cm
# response <- read_csv('./data/final/stage_mrms_response.csv') %>%
#   mutate(across(c(datetime_peak, datetime_min, start_time.y, end_time.y), mdy_hm)) %>%
#   mutate(date = mdy(date)) %>%
#   mutate(site = if_else(site == 'mont',
#                         'montgomery',
#                         site)) %>%
#   mutate(site = if_else(site == 'mich',
#                         'michigan',
#                         site))
#   
# 
# # read in SP
# sp <- read_csv('./data/final_model_inputs/sp_2000_2019_avg_catchments.csv')
# elev <- read_csv('./data/final_model_inputs/elev_range.csv')
# hypso <- read_csv('./data/final_model_inputs/hypso.csv')
# ic <- read_csv('./data/final_model_inputs/IC_mean.csv')
# inputs1 <- read_csv('./data/final_model_inputs/inputs1.csv')
# 
# inputs2 <- read_csv('./data/final_model_inputs/inputs2.csv') %>%
#   distinct(site, .keep_all = T) %>%
#   select(-c(relative_elev, relative_area))
#   
# ndvi_geo <- read_csv('./data/final_model_inputs/ndvi&geo.csv') %>%
#   rename(site = ID)
# 
# pwd <- read_csv('./data/final_model_inputs/pwd.csv') %>%
#   mutate(date = mdy(Date)) %>%
#   dplyr::select(-Date)
# 
# # join all model inputs together, except PWD b/c that's based on date
# df_list <- list(elev, hypso, ic, inputs1, inputs2, ndvi_geo, sp)
# 
# inputs <- reduce(df_list, left_join, by = c("site")) %>%
#   dplyr::select(-c(2:5, 9:13, 23:25, 38, 41:42)) %>%
#   dplyr::select(-c(28:30, 38:43))
# 
# write_csv(inputs, './data/final_model_inputs/inputs_combine.csv')

inputs <- read_csv('./data/final_model_inputs/inputs_combine.csv')

#response <- left_join(response, pwd, by = c('site', 'date'))

#all <- left_join(response, inputs, by = 'site')

```

## Histograms and boxplots

```{r}

# create snow persistence categories
inputs <- inputs %>% 
  mutate(sp_cat = if_else(SP_mean > 60,
                          'high',
                          'low'))

# Get names of variables
numeric_cols <- names(inputs)[2:39]

# histograms
plots <- map(numeric_cols, ~{
  ggplot(inputs, aes(x = .data[[.x]], fill=sp_cat)) +
    geom_density(alpha = 0.6) +
    facet_wrap(~fire, scales = "free") +
    theme_bw() +
    labs(title = paste(.x))
})

plots

# boxplots 
plots <- map(numeric_cols, ~{
  ggplot(inputs, aes(x = fire, y = .data[[.x]], fill=sp_cat)) +
    geom_boxplot() +
    theme_bw() +
    labs(title = paste(.x))
})

plots

```

## Correlations

```{r}

corr_prep <- inputs %>%
  select(where(is.numeric))

corr_matrix <- cor(corr_prep, use = "complete.obs")

ggcorrplot(corr_matrix, method = "square", 
           hc.order = TRUE,
           type = "lower", 
           lab = TRUE, 
           lab_col = "black", 
           lab_size = 3, 
           colors = c("blue", "white", "red")) +
  theme(
    plot.margin = margin(1, 1,1,1),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y = element_text(hjust = 1))

```

## Input figures 

Two-way anova and Tukey
UPDATE CAN'T DO THIS HERE. NEED TO DO A NON PARAMETRIC TEST

This doesn't include temporal inputs (rain metrics and pwd)

```{r}

# remove the unburned sites from inputs for dnbr and ndvi
inputs_edit <- inputs %>%
  mutate(mean_dnbr = if_else(site %in% c('bighorn',
                                         'michigan',
                                         'p1'),
                             NA,
                             mean_dnbr),
         NDVI_2021.x = if_else(site %in% c('bighorn',
                                           'michigan',
                                           'p1'),
                               NA,
                               NDVI_2021.x),
         NDVI_2022.x = if_else(site %in% c('bighorn',
                                           'michigan',
                                           'p1'),
                               NA,
                               NDVI_2022.x),
         NDVI_2023.x = if_else(site %in% c('bighorn',
                                           'michigan',
                                           'p1'),
                               NA,
                               NDVI_2023.x))

# make df long & remove the categorical geology
inputs_long <- inputs_edit %>%
  select(-c(site, geo_general.x, geology.x)) %>%
  pivot_longer(!c(fire, sp_cat), 
               names_to = 'vars',
               values_to = 'vals')

# # function to run two-way anova and Tukey letters
# tukey_results <- inputs_long %>%
#   mutate(fire = as.factor(fire),
#          sp_cat = as.factor(sp_cat)) %>%
#   group_split(vars) %>%
#   map(function(df) {
#     # two-way ANOVA
#     model <- aov(vals ~ fire * sp_cat, data = df)
#     
#     # Tukey HSD
#     tukey_test <- TukeyHSD(model)
#     
#     # Tukey letters based on p val
#     tukey_letters <- multcompLetters4(model, tukey_test)
# 
#     list(
#       var = unique(df$vars),
#       model = model,
#       tukey = tukey_test,
#       letters = tukey_letters
#     )
#   })
# 
# 
# # Convert results into a tibble
# tukey_df <- tibble(
#   var = map_chr(tukey_results, "var"),
#   model = map(tukey_results, "model"),
#   tukey = map(tukey_results, "tukey"),
#   letters = map(tukey_results, "letters"))
# 
# # extract letters 
# letters_all_vars <- tukey_df %>%
#   mutate(
#     letters_fire_sp_cat = map(letters, ~ {
#       letters_vec <- .x$`fire:sp_cat`$Letters
#       enframe(letters_vec, name = "group", value = "letter")})) %>%
#   select(var, letters_fire_sp_cat) %>%
#   unnest(letters_fire_sp_cat) %>%
#   separate_wider_delim(group, ":", names = c('fire', 'sp_cat'))
# 
# # bring letters back into main df
# inputs_tukey <- inputs_long %>%
#   rename(var = vars) %>% 
#   left_join(., letters_all_vars, by = c('var', 'fire', 'sp_cat')) %>%
#   filter(!var %in% c('geo_coded', 
#                      'geo_general_code', 
#                      'max_elev', 
#                      'min_elev', 
#                      'slope'))
# 
# # find the max to place the letters in the plots
# inputs_tukey <- inputs_tukey %>% 
#   group_by(var, fire, sp_cat) %>%
#   mutate(y_text = max(vals, na.rm = TRUE) * 1.01) %>%  # Slightly above max value
#   ungroup()
# 
# # basic fig, no formatting
# ggplot(inputs_tukey, aes(x=fire, 
#                          y=vals, 
#                          fill=sp_cat)) + 
#   geom_boxplot() +
#   geom_text(aes(label = letter, y = y_text), 
#             position = position_dodge(width = 0.75),  # Align with boxplots
#             size = 6, 
#             vjust = 0) + 
#   facet_wrap(~var, scales='free_y', ncol=3) +
#    scale_y_continuous(expand = expansion(mult = c(0.1, 0.15)))
# 
# ggsave(
#   '/Users/megansears/Documents/Repos/post-fire_rainfall/figures/SR_response/vars_boxplot.png',
#        dpi=600,
#        width=12,
#        height=20)

 ggplot(inputs_long, aes(x=fire, 
                         y=vals,
                         fill=sp_cat)) +
  geom_boxplot() +
  facet_wrap(~vars, scales='free_y', ncol=3) +
  theme_bw(base_size=14)

ggsave(
  '/Users/megansears/Documents/Repos/post-fire_rainfall/figures/SR_response/vars_boxplot.png',
       dpi=600,
       width=12,
       height=20)


# for actual figure - select soils & geo, shape, burn & veg
vars <- inputs_long %>%
  filter(vars %in% c('AVG_CLAY',
                     'AVG_KSAT',
                     'aws0150wta',
                     'ELONGATION.x',
                     'flow_length_m',
                     'frac_valley',
                     'hypso75',
                     'slope30_frac',
                     'mean_dnbr',
                     'NDVI_2021.x',
                     'NDVI_2022.x',
                     'NDVI_2023.x',
                    'hypso_integral')) %>%
    mutate(vars = case_match(vars,
    "AVG_CLAY" ~ "Clay",
    "AVG_KSAT" ~ "Ksat",
    "aws0150wta" ~ "Available water storage",
    "ELONGATION.x" ~ "Elongation",
    "flow_length_m" ~ "Max flow length",
    "frac_valley" ~ "Valley and hollows fraction",
    "hypso75" ~ "Hypsometric 75",
    "slope30_frac" ~ "Slope > 30 fraction",
    "mean_dnbr" ~ "Mean dNBR",
    "NDVI_2021.x" ~ "NDVI 2021",
    "NDVI_2022.x" ~ "NDVI 2022",
    "NDVI_2023.x" ~ "NDVI 2023",
    'hypso_integral' ~ 'Hypsometric integral'))
  
# basic fig, no formatting
ggplot(vars, aes(x=fire, 
                 y=vals,
                 fill=sp_cat)) + 
  geom_boxplot(           
    color = "black",          
    size = 0.8,                 
    width = 0.4, ) +
  # geom_jitter(aes(color = sp_cat),
  #   width = 0.1,             
  #   height = 0,              
  #   size = 1.2,               
  #   alpha = 0.3) + 
  scale_fill_manual(values = c('#7570B3', "#D95F02")) +
  theme_bw(base_size = 20) +
  # labs(x = 'Elevation',
  #   y = 'MI60 (mm/hr)') +
  theme(
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white"),
    strip.background = element_blank(),
    text = element_text(color = "black"),
    axis.title = element_text(color = "black"),
    axis.text = element_text(color = "black")) +
   #legend.position = "none") +
  facet_wrap(~vars, scales='free_y', ncol=3) 

ggsave(
  '/Users/megansears/Documents/Repos/post-fire_rainfall/figures/SR_response/vars_boxplot_less.png',
       dpi=600,
       width=12,
       height=12)

```

# Response

## Add rain metrics and PWD to response
don't need to run anymore

## Rain and PWD figures
need to move up

```{r}

# # this is only for events > 5 cm
# response <- read_csv('./data/final/stage_mrms_response.csv') %>%
#   mutate(across(c(datetime_peak, datetime_min, start_time.y, end_time.y), mdy_hm)) %>%
#   mutate(date = mdy(date)) %>%
#   mutate(site = if_else(site == 'mont',
#                         'montgomery',
#                         site)) %>%
#   mutate(site = if_else(site == 'mich',
#                         'michigan',
#                         site))
# 
# # need to add new metrics to response dataframe
# add <- read_csv('./data/final/mrms/catchment_mrms_intensities_wmean_exact_addedmetrics.csv') %>%
#   select(site = ID,
#          start_time.y = start_time,
#          halfP_datetime,
#          MI60_datetime) %>%
#   mutate(site = tolower(site)) %>%
#   mutate(site = if_else(site == 'mtcampus',
#                         'mtcamp', site))
# 
# # add the new metrics needed for lag to peak
# response <- left_join(response, 
#                       add, 
#                       by = c('site', 'start_time.y'))
# 
# # add lag pwd to the response df
# pwd <- read_csv('./data/final_model_inputs/pwd.csv') %>%
#   mutate(date = mdy(Date)) %>%
#   dplyr::select(-Date) %>%
#   dplyr::select(date, lag_pwd, site)
# 
# response <- left_join(response, 
#                       pwd, 
#                       by = c('site', 'date'))
# 
# # first lets drop NDVI 3 columns and create it's own
# ndvi <- inputs %>%
#   select(site, 
#          NDVI_2021 = NDVI_2021.x, 
#          NDVI_2022 = NDVI_2022.x, 
#          NDVI_2023 = NDVI_2023.x) %>%
#   pivot_longer(!site, 
#                names_to = 'year', 
#                values_to = 'NDVI') %>%
#   mutate(year = as.numeric(sub("^NDVI_", "", year)))
#   
# 
# # add other inputs (non climate) to response
# response <- response %>%
#   mutate(year = year(date))
# 
# response <- left_join(response, 
#                       ndvi, 
#                       by=c('site', 'year'))

# add frac glacial that was added after response_inputs was created
# inputs_glac <- inputs %>%
#   select(site, frac_glacial)
# 
# response <- left_join(response, inputs_glac, by = 'site')
 
# write.csv(response, './data/final_model_inputs/response_inputs.csv')

```

## Response prep

-Here, I tested stage rise normalized by channel width (measured via GIS) and area
-I plugged both those response variables into a RF model, the results didn't make sense
-Staying with stage rise (not normalized for now)

-Calculating lag to peak: 
  -I went back to MRMS metrics and determined the first timestep when half of the event P is reached
  -Also, added the timestep when when max MI60 occurrs
  -lag to peak = datetime of peak stage - halfP_datetime
  -lag to peak will also = datetime of peak stage - rain start_time

```{r}

# need to add lag to peak to this, glacial deposits, and what to do when MRMS is NA
response <- read_csv('./data/final_model_inputs/response_inputs.csv')

# # divide the area and channel width and area
# response <- response %>%
#   mutate(stage_rise_area = stage_rise_cm / area_km2,
#          stage_rise_channel = stage_rise_cm / estimated_chanwidth_m)
# 
# # stage rise plots
# stage_rise_plots <- response %>%
#   select(fire, sp_cat, stage_rise_cm, stage_rise_area, stage_rise_channel) %>%
#   pivot_longer(!c(fire, sp_cat), names_to='stage_rise_type', values_to = 'stage_rise') %>%
#   ggplot(., aes(fire, stage_rise, fill = sp_cat)) + 
#   geom_boxplot() + 
#   facet_wrap(~stage_rise_type)
# 
# stage_rise_plots

# add lag to peak
response <- response %>%
  mutate(datetime_peak = mdy_hm(datetime_peak),
         halfP_datetime = mdy_hm(halfP_datetime),
         start_time = mdy_hm(start_time)) %>%
  mutate(lag2peak_halfP = as.numeric((datetime_peak - halfP_datetime)/3600),
         lag2peak_Pstart = as.numeric((datetime_peak - start_time)/3600)) 

ggplot(response, aes(x=fire, y=lag2peak, fill=sp_cat)) + geom_boxplot()

```

## Response figures

```{r}

```

# RF modeling

Concerned about sample size especially when splitting by fire

## Stage rise

### Both fires

-Initially tried the RF modeling w/ stage rise normalized by channel width (GIS)
and area. Neither made sense so sticking w/ stage rise for now

-The variables selected were based on boxplots of fire and sp category and 
picked to represent topographic, soil, climate and burn characteristics

```{r}

# subset dataframe based on variables selected
df <- response %>%
  select(stage_rise_cm, 
         MI60_mmhr, 
         #fire, # at bottom of importance based on initial run
         lag_pwd,
         hypso75, 
         mean_dnbr, 
         AVG_CLAY, 
         AVG_KSAT, 
         elongation, 
         aws0150wta, 
         #geo_general, # at bottom of impotance based on inital run
         NDVI, 
         frac_valley,
         flow_length_m, 
         slope30_frac, 
         SP_mean,
         hypso_integral,
         year,
         #slope23_frac, # less important than slop30 based on initial run
         #hypso_integral, # less important than hypso75 based on initial run
         frac_glacial) %>%
  drop_na()

# RF model
rf <- randomForest(stage_rise_cm ~., 
                          mtry = 5, 
                          ntree = 50000, 
                          data = df)

# check model performance for % variance explained
rf # only 20%

# plot ofr increased node purity
varImpPlot(rf) 

varImps <- rf$importance %>%
  as.data.frame() # save increased node purity (metric of variable importance) to data frame

sr_all_RF <- varImps %>%
  mutate(., normINP = IncNodePurity/max(IncNodePurity)) %>% # IncNodePurity is the metric for regression RFs (continous data)
  rownames_to_column('Predictor') %>%
  mutate(Predictor = as.factor(Predictor)) %>%
  ggplot(aes(x=reorder(Predictor, normINP), y=normINP)) + theme_bw(base_size = 20) +
      geom_bar(stat='identity', color='black', fill='black') +
      coord_flip() +
      labs(y='Normalized Variable Importance') +
      theme(axis.title.y = element_blank()) +
  theme(legend.position="bottom",
        text = element_text(size=30))

sr_all_RF

```

### CPF

```{r}

# subset dataframe based on variables selected
df <- response %>%
  filter(fire == 'cpf') %>% 
  select(stage_rise_cm, 
         MI60_mmhr, 
         #fire, # don't need here
         lag_pwd,
         hypso75, 
         mean_dnbr, 
         AVG_CLAY, 
         AVG_KSAT, 
         elongation, 
         aws0150wta, 
         #geo_general, # at bottom of impotance based on inital run
         NDVI, 
         frac_valley,
         flow_length_m, 
         slope30_frac, 
         SP_mean,
         hypso_integral,
         year,
         #slope23_frac, # less important than slop30 based on initial run
         #hypso_integral, # less important than hypso75 based on initial run
         frac_glacial) %>%
  drop_na()

# RF model
rf <- randomForest(stage_rise_cm ~., 
                          mtry = 5, 
                          ntree = 1000, 
                          data = df)

# check model performance for % variance explained
rf # only 20%

# plot ofr increased node purity
varImpPlot(rf) 

varImps <- rf$importance %>%
  as.data.frame() # save increased node purity (metric of variable importance) to data frame

sr_cpf_RF <- varImps %>%
  mutate(., normINP = IncNodePurity/max(IncNodePurity)) %>% # IncNodePurity is the metric for regression RFs (continous data)
  rownames_to_column('Predictor') %>%
  mutate(Predictor = as.factor(Predictor)) %>%
  ggplot(aes(x=reorder(Predictor, normINP), y=normINP)) + theme_bw(base_size = 20) +
      geom_bar(stat='identity', color='black', fill='black') +
      coord_flip() +
      labs(y='Normalized Variable Importance') +
      theme(axis.title.y = element_blank()) +
  theme(legend.position="bottom",
        text = element_text(size=30))

sr_cpf_RF

```

### ETF

```{r}

# subset dataframe based on variables selected
df <- response %>%
  filter(fire == 'etf') %>% 
  select(stage_rise_cm, 
         MI60_mmhr, 
         #fire, # don't need here
         lag_pwd,
         #hypso75, # hypso integral more important here 
         mean_dnbr, 
         AVG_CLAY, 
         AVG_KSAT, 
         elongation, 
         aws0150wta, 
         #geo_general, # don't need here
         NDVI, 
         frac_valley,
         flow_length_m, 
         slope30_frac, 
         SP_mean,
         hypso_integral,
         year,
         #slope23_frac, # about the same as slope 30 so removing to stay consistent w/ others
         hypso_integral, 
         frac_glacial) %>%
  drop_na()

# RF model
rf <- randomForest(stage_rise_cm ~., 
                          mtry = 5, 
                          ntree = 1000, 
                          data = df)

# check model performance for % variance explained
rf # only 7%, very low

# plot ofr increased node purity
varImpPlot(rf) 

varImps <- rf$importance %>%
  as.data.frame() # save increased node purity (metric of variable importance) to data frame

sr_etf_RF <- varImps %>%
  mutate(., normINP = IncNodePurity/max(IncNodePurity)) %>% # IncNodePurity is the metric for regression RFs (continous data)
  rownames_to_column('Predictor') %>%
  mutate(Predictor = as.factor(Predictor)) %>%
  ggplot(aes(x=reorder(Predictor, normINP), y=normINP)) + theme_bw(base_size = 20) +
      geom_bar(stat='identity', color='black', fill='black') +
      coord_flip() +
      labs(y='Normalized Variable Importance') +
      theme(axis.title.y = element_blank()) +
  theme(legend.position="bottom",
        text = element_text(size=30))

sr_etf_RF

```

# Archive
Stage rise

```{r}
# # Stage rise
# 
# ```{r}
# 
# ggplot(all, aes(x=site, y=stage_rise_cm)) +
#   geom_boxplot() +
#   scale_y_log10() +
#   theme_bw(base_size=20)
# 
# # lag to peak
# lag2p <- all %>%
#   dplyr::select(site, datetime_peak, start_time.y, stage_rise_cm) %>%
#   mutate(lag2peak = datetime_peak - start_time.y) %>%
#   filter(!lag2peak<0)
# 
# ggplot(lag2p, aes(x=site, y=as.numeric(lag2peak))) +
#   geom_boxplot() +
#    scale_y_log10() +
#   theme_bw(base_size=20)
# 
# all <- all %>%
#   mutate(sp_cat = if_else(SP_mean > 60,
#                           'high',
#                           'low'))
# 
# ggplot(all, aes(x=sp_cat, y=stage_rise_cm, fill=fire)) +
#   geom_boxplot() +
#   #scale_y_log10() +
#   theme_bw(base_size=20)
# 
# lag2p_join <- lag2p %>%
#   dplyr::select(site, lag2peak)
# 
# all <- left_join(all, lag2p_join, by = 'site')
# 
# ggplot(all, aes(x=sp_cat, y=as.numeric(lag2peak), fill=fire)) +
#   geom_boxplot() +
#   theme_bw(base_size=20)


```

Old corr

```{r}
# response_corr <- response %>%
#   select(stage_rise_cm, 
#          MI60_mmhr.y, 
#          MI30_mmhr.y, 
#          event_sum_mm.y, 
#          duration_hr.y)
# 
# corr_matrix <- cor(response_corr, use = "complete.obs")
# 
# ggcorrplot(corr_matrix, method = "square", 
#            hc.order = TRUE,
#            type = "lower", 
#            lab = TRUE, 
#            lab_col = "black", 
#            lab_size = 3, 
#            colors = c("blue", "white", "red")) +
#   theme(
#     plot.margin = margin(1, 1,1,1),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     axis.text.y = element_text(hjust = 1))
# 
# # test what it looks like when dropping missing mrms
# response_corr_no0 <- response_corr %>%
#   filter(!event_sum_mm.y == 0)
# 
# corr_matrix <- cor(response_corr_no0, use = "complete.obs")
# 
# ggcorrplot(corr_matrix, method = "square", 
#            hc.order = TRUE,
#            type = "lower", 
#            lab = TRUE, 
#            lab_col = "black", 
#            lab_size = 3, 
#            colors = c("blue", "white", "red")) +
#   theme(
#     plot.margin = margin(1, 1,1,1),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     axis.text.y = element_text(hjust = 1))
# 
# # lets look at cpf with no 0 mrms
# response_cpf <- response %>%
#   filter(fire == 'cpf',
#          !event_sum_mm.y == 0) %>%
#   select(stage_rise_cm, 
#          MI60_mmhr.y, 
#          MI30_mmhr.y, 
#          event_sum_mm.y,
#          duration_hr.y)
# 
# corr_matrix <- cor(response_cpf, use = "complete.obs")
# 
# ggcorrplot(corr_matrix, method = "square", 
#            hc.order = TRUE,
#            type = "lower", 
#            lab = TRUE, 
#            lab_col = "black", 
#            lab_size = 3, 
#            colors = c("blue", "white", "red")) +
#   theme(
#     plot.margin = margin(1, 1,1,1),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     axis.text.y = element_text(hjust = 1))
# 
# # response etf
# response_etf <- response %>%
#   filter(fire == 'etf',
#          !event_sum_mm.y == 0) %>%
#   select(stage_rise_cm, 
#          MI60_mmhr.y, 
#          MI30_mmhr.y, 
#          event_sum_mm.y,
#          duration_hr.y)
# 
# corr_matrix <- cor(response_etf, use = "complete.obs")
# 
# ggcorrplot(corr_matrix, method = "square", 
#            hc.order = TRUE,
#            type = "lower", 
#            lab = TRUE, 
#            lab_col = "black", 
#            lab_size = 3, 
#            colors = c("blue", "white", "red")) +
#   theme(
#     plot.margin = margin(1, 1,1,1),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     axis.text.y = element_text(hjust = 1))
# 
# # need to look by site
# response_site <- response %>%
#   filter(!event_sum_mm.y == 0,
#          !site %in%  c('michigan',
#                        'p1'))
# 
# corr_bysite <- function(siteID){
#   
#   corr_site <- response_site %>% 
#   filter(site == siteID) %>%
#   select(stage_rise_cm, 
#          MI60_mmhr.y, 
#          MI30_mmhr.y, 
#          event_sum_mm.y,
#          duration_hr.y)
#   
#   corr_matrix <- cor(corr_site, use = "complete.obs")
#   
#   ggcorrplot(corr_matrix, method = "square", 
#            hc.order = TRUE,
#            type = "lower", 
#            lab = TRUE, 
#            lab_col = "black", 
#            lab_size = 3, 
#            colors = c("blue", "white", "red")) +
#   theme_bw(base_size=12) +
#     ggtitle(label = siteID) +
#     theme(
#       plot.margin = margin(-1, -1, -1, -1))
#   
# }
# 
# siteID <- unique(response_site$site)
# 
# corr_plots <- map(siteID, corr_bysite)
# corr_plots
# 
# library(patchwork)
# 
# # Combine the plots using patchwork, arranging them in a grid
# combined_plot <- wrap_plots(corr_plots, ncol = 4)
# 
# ggsave("./figures/SR_response/combined_corr.png", combined_plot, width = 40, height = 30, dpi = 300)


```



