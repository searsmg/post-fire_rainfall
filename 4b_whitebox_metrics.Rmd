---
title: "whitebox_metrics"
author: "Megan Sears"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = F,
  message = F, 
  warning  = F)

# load packages
library(here)
library(tidyverse)
library(whitebox)
library(terra)
library(tidyterra)
library(beepr)
library(stringr)

```

```{r}

#whitebox::install_whitebox() # I think this only has to be done once

```

# Prep the shp and tif files

```{r}

# create catchments path and pull in data (will need both)
catchments_path <- './data/GIS/catchments_all_lidar.shp'

catchments <- vect('./data/GIS/catchments_all_lidar.shp') %>%
  mutate(site = ifelse(site == "mm", "mm_et", site))

# create lidar (DEM) path and pull in data (will need both)
# the script assumes the DEM is clipped to the catchments
# if not use code commented out below
# mask the lidar to polygons first (we don't need elevation values outside of the catchments)
# lidar <- rast(lidar_path)
# catchments <- vect(catchments_path)
# 
# lidar_mask <- mask(x = lidar, mask = catchments)
# writeRaster(lidar_mask, './data/GIS/clipped_lidar.tif', overwrite = T) # output

# update the lidar path to the clipped lidar
lidar_path <- './data/GIS/clipped_lidar.tif'
lidar <- rast('./data/GIS/clipped_lidar.tif')

```

# Elongation ratio

```{r}

# Run the elongation tool - note, values append to the shp attribute table
wbt_elongation_ratio(catchments_path)

# can read it in to check it
elong <- vect(catchments_path)
head(elong) # sample top few rows

```

# Related circumscribing circle 

Mcgarigal et al. 2002

```{r}

wbt_related_circumscribing_circle(catchments_path)

# can read it in to check it
circle <- vect(catchments_path)
head(circle) # sample top few rows

```

# Geomorphons

More info and key: https://www.whiteboxgeo.com/manual/wbt_book/available_tools/geomorphometric_analysis.html#Geomorphons

-After getting the geomorphon data: get the fraction of valley & hollow in the catchment (done)
-Then somehow valley bottom width (possibly do in Arc) - done manually, but data read in below

```{r}

wbt_geomorphons(
    dem = lidar_path, 
    output = './data/GIS/geomorphons.tif')

# make sure it looks right, view with mapview
geomorphons <- rast('./data/GIS/geomorphons.tif')
#plot(geomorphons) # take a quick look

# get the valley/holllow fraction
# first extract cell values within catchments
values <- terra::extract(x = geomorphons,
                y = catchments,
                touches = T)

# find the valley and hollows (7 & 9)
valley_frac <- values %>%
  group_by(ID) %>% # group by site
  mutate(valley_hollow = if_else(geomorphons %in% c(7,9),
                               1, 0)) %>%
  summarize(frac_valley = sum(valley_hollow)/n(),
            count = n()) # sum the valley & hollow cells and divide by total cells in catchment

# join back to the catchments attribute table  
metrics <- left_join(valley_frac, 
                         as.data.frame(catchments), 
                         by = 'ID')

```

# Flow accumulation and recharge areas

The code below gets flow accumulation, filters values by >50k, converts the raster flow lines to polylines,
finds flat areas in slope tif (less than 10), then intersects the flat/50k polygons with geomorphons 7,8,9,
and finds the portion of watersheds that have these polygons (flat,50k, and geomorphons 7,8,9).
 
```{r}

# get flow accumulation
wbt_flow_accumulation_full_workflow(
  dem = lidar_path,
  out_dem = './data/GIS/dem_flow.tif',
  out_pntr = './data/GIS/pntr_flow.tif',
  out_accum = './data/GIS/flow_accum.tif')

# filter out by 50k
flow <- rast('./data/GIS/flow_accum.tif')

filter <- ifel(flow < 50000, NA, 1) # filter by 50,000 ## CHECK TO SEE IF BENNY GETS FILTERED OUT

# raster to polyline
wbt_raster_to_vector_lines(
    filter, 
    output = 'flow_lines.shp') # update so it doest go to main dir

# need slope then filter slope by <10
wbt_slope(dem = lidar_path,
                   output = './data/GIS/slope.tif')

# read it in slope
slope <- rast('./data/GIS/slope.tif')

# filter slope by 10
flat <- ifel(slope > 10, NA, 1)
beep(sound = 8)

writeRaster(flat, './data/GIS/flat_areas.tif', overwrite=T) 

# flat areas tif to polygons
wbt_raster_to_vector_polygons(
    input = './data/GIS/flat_areas.tif', 
    output = './data/GIS/flat_polygons.shp')
beep(sound=8)

# read in the flat areas shp
flat_areas <- vect('./data/GIS/flat_polygons.shp')

# now intersect flat polygons with flow lines
# read in flow lines
flow_lines <- vect('./data/GIS/flow_lines.shp')

# make shp files valid (may not be needed)
flat_cor <- makeValid(flat_areas)
flow_cor <- makeValid(flow_lines)

# intersect flat and flow and create pairs so we know which flat polygons to keep
flat_flow <- terra::relate(flat_cor, flow_cor, relation = 'intersects', pairs = T) %>%
  as.data.frame()

# filter it by flat_cor$FID by values in flat_flow$id.x (id.x comes from the x in relate above)
filtered_flat_cor <- flat_cor[flat_cor$FID %in% flat_flow$id.x, ]

# export flat areas with flow >50k as shp
writeVector(filtered_flat_cor, './data/GIS/test1.shp', overwrite = T)
# !!!! some of the polygons capture ridges so filter for geomorphons 789 now

# read in flat areas with 50k flow
filtered_flat_cor <- vect('./data/GIS/test1.shp')

# now also filter by geomorphons for 7,8,9 with the flat_flow area (slope less than 10 & 50k flow
# Specify the values to keep in geomorphons
keep <- c(7, 8, 9)

# Clamp geomorphons based on the specified values
geomor_789 <- clamp(geomorphons, 
                   lower = 7,
                   upper = 9,
                   values = F)
beep(sound=8)

# export
writeRaster(geomor_789, './data/GIS/geomor789.tif')

# make geomorph 789 tif to polygons
wbt_raster_to_vector_polygons(
    input = './data/GIS/geomor789.tif', 
    output = './data/GIS/geomor789_poly.shp')
beep(sound=8)

# read in geomorphons 789 polygon
geomor789_poly <- vect('./data/GIS/geomor789_poly.shp')

geomor789_poly <- makeValid(geomor789_poly)

# intersect the flat, 50k & slope <10 with geomorphons 789 polygons
geomor789_flat_50k <- intersect(filtered_flat_cor, geomor789_poly)
beep(sound=8)

# export
writeVector(geomor789_flat_50k, './data/GIS/geomor789_flat_50k.shp')
beep(sound=8)

# read in polygons that contain flat areas, slope < 10, and geomorphons 789)
geomor789_flat_50 <- vect('./data/GIS/geomor789_flat_50k.shp') 

# find area that has this criteria in each catchment
# first intersect the 3 criteria w/ catchments
flat_50_789_site <- intersect(geomor789_flat_50, catchments) %>%
  mutate(unique_id = row_number()) %>% # unique id that will be joined later
  tidyterra::select(c(unique_id, site)) # keep only unqiue id and site

# we have recharge areas now from intersect above
# find the area using expanse function
recharge_area <- expanse(flat_50_789_site, unit = 'km') %>%
  as.data.frame() %>%
  rename(recharge_area_km2 = 1) %>%
  mutate(unique_id = row_number())

# join the recharge area df back to flat_50_789 and group by site
# summarize the areas for each polygon that fits the criteria (by site)
recharge <- as.data.frame(flat_50_789_site) %>%
  left_join(., recharge_area, by = 'unique_id') %>%
  group_by(site) %>%
  summarize(recharge_total_km2 = sum(recharge_area_km2))

# join to metrics df
metrics <- left_join(metrics, recharge, by = 'site') %>%
  mutate(catchment_area_km2 = Shape_Area / 1e6) %>%
  mutate(frac_recharge_area = recharge_total_km2 / catchment_area_km2)
         

```

Everything above is done and final <3

# Hypsometric analyses

```{r}
# vector to raster (hypso wants catchments as rasters)
wbt_vector_polygons_to_raster(
    input = catchments_path,
    output = './data/GIS/catchemnts_outline.tif',
    field = 'ID',
    base = lidar_path)
beep(sound=8)

# hypsometric analysis
wbt_hypsometric_analysis(
  inputs=lidar_path,
  output='./data/GIS/hypso.csv',
  watershed = './data/GIS/catchemnts_outline.tif')
beep(sound=8)

# read in hypsometric csv and edit a few things
hypso <- read_csv('./data/GIS/hypso.csv', skip = 70) %>%
  slice(-c(3:672)) %>%
  separate(1, into = paste0("new_col", 1:3076), sep = ",") # this needs to be updated in future to know how many columns

# get the x values 
hypso_x <- slice(hypso, 1) %>%
  pivot_longer(everything()) %>%
  rename(x=value)

# get the y values
hypso_y <- slice(hypso, 2) %>%
  pivot_longer(everything()) %>%
  rename(y=value)

# value of a/A at h/H=0.25, 0.50, 0.75
# 
# at 0.25, 1-a/A is the fraction of watershed area in the lower elevation quartile
# 0.5, a/A is the fraction of watershed area in the upper half of elevations
# 0.75, a/A is the fraction of watershed area in the upper elevation quartile

# get values above
hypso_join <- left_join(hypso_x, hypso_y, by = 'name') %>%
  mutate(id = cumsum(grepl("\\[", x))) %>%
  select(-name) %>%
  mutate(x = str_replace_all(x, "[^0-9.]", "")) %>%
  mutate(y = str_replace_all(y, "[^0-9.]", "")) %>%
  rename(relative_area = x, relative_elev = y) %>%
  mutate(relative_area = as.numeric(relative_area),
         relative_elev = as.numeric(relative_elev)) %>%
  group_by(id) %>%
    filter(abs(relative_area-25)==min(abs(relative_area-25)) |
           abs(relative_area-50)==min(abs(relative_area-50)) |
           abs(relative_area-75)==min(abs(relative_area-75))) %>% # this code filters relative area by value closest to 25, 50, 75
  rename(ID = id) # rename so it can match metrics df
         
# add to metrics df
metrics <- left_join(metrics, hypso_join, by = 'ID')


```

# Hysometric analyses
Above did not work so try using a map function

```{r}

get_hypso_csv <- function(site_name) {
  # Filter the data for the specified site
  site_data <- catchments %>%
    tidyterra::filter(site == site_name)

  # Mask the lidar data for the specified site
  site_rast <- terra::crop(clipped_lidar, 
                           site_data,
                           mask = T)

  # Write the masked lidar data to a GeoTIFF file
  writeRaster(site_rast, paste0('./data/GIS/', site_name, '_lidar.tif'), overwrite = TRUE)

  # Hypsometric analysis
  wbt_hypsometric_analysis(
    inputs = paste0('./data/GIS/', site_name, '_lidar.tif'),
    output = paste0('./data/GIS/', site_name, '_hypso.csv'))
  
  beep(sound = 8)
}

site_names <- catchments$site  # Assuming your site names are in the 'site' column
map(site_names, get_hypso_csv)

# now we need to get the csv into R (next step)

```

# Flowpath length

```{r}

# Assuming all_sites is your data frame with site names
site_names <- catchments$site

# Define a function to run downslope flowpath length for a given site
run_downslope_flowpath <- function(site_name) {
  current_site_flowpath <- paste0('./data/GIS/site_flowlength/', site_name, '_flow_length.tif')
  current_site_lidar <- paste0('./data/GIS/site_lidar/', site_name, '_lidar.tif')

  wbt_downslope_flowpath_length(
    d8_pntr = './data/GIS/pntr_flow.tif',
    output = current_site_flowpath,
    watersheds = current_site_lidar
  )
}

# Use map to apply the function for each site in site_names
map(site_names, run_downslope_flowpath)

#######################################################################################
# find the max length
site_names <- catchments$site

get_flowlength <- function(site_name){

fl <- rast(paste0('./data/GIS/site_flowlength/', site_name, '_flow_length.tif'))

site_catch <- catchments %>%
  tidyterra::filter(site == site_name)


max_length <- terra::zonal(fl, site_catch, fun = 'max') %>% # this is in meters
  mutate(site = site_name) %>%
  rename(flow_length = 1)

}


all_fl <- map_df(site_names, get_flowlength) %>%
  bind_rows()

beep(sound=8)

# join back to metrics df
metrics <- left_join(metrics, 
                     all_fl, 
                         by = 'site') %>%
  rename(flow_length_m = flow_length)

```

# Valley bottom width

```{r}

# done in arc gis
vb_width <- read_csv('./data/GIS/valley_bottom_width.csv') %>%
  group_by(site) %>%
  summarize(avg_vbw_m = mean(v_bottom_width_m))

# join to metrics
metrics <- left_join(metrics, vb_width, by = 'site')

```

# Index of connectivity

Following are needed:
-Slope
-Flow direction
-Flow accumulation filtered by 1000
-DEM
-Downstream flow length

Lets do this workflow for one site to start

```{r}
# slope for all sites, then +0.005
slope <- rast('./data/GIS/slope.tif')
s <- slope + 0.005

dadd_boundary <- catchments %>%
  tidyterra::filter(site == 'dadd')

dadd_slope <- terra::crop(s, 
                          dadd_boundary,
                          mask = T)
# flow accumulation for all sites, then +1
flow_acc <- rast('./data/GIS/flow_accum.tif')
flow_acc1 <- flow_acc + 1

dadd_acc <- terra::crop(flow_acc1,
                        dadd_boundary,
                        mask = T)

# flow direction - come back to
flow_dir <- rast('./data/GIS/pntr_flow.tif')


# inverse of c*s (c = clipped lidar [or DEM])
inv_cs <- 1 / (clipped_lidar * s)

# crop inv_cs by site
dadd_inv_cs <- terra::crop(inv_cs,
                           dadd_boundary,
                           mask = T)

writeRaster(dadd_inv_cs, './data/GIS/site_flowlength/weighted/dadd_weight.tif')

# crop pntr flow by site
dadd_dir <- terra::crop(rast('./data/GIS/pntr_flow.tif'),
                        dadd_boundary,
                        mask = T)

writeRaster(dadd_dir, './data/GIS/flowdir/dadd_dir.tif')

##############################################
# downstream flow length weighted by inv_cs 

# Define a function to run downslope flowpath length for a given site
current_site_flowpath <- './data/GIS/site_flowlength/weighted/dadd_flow_length.tif'
current_site_dir <- './data/GIS/flowdir/dadd_dir.tif'
current_site_lidar <- './data/GIS/site_lidar/dadd_lidar.tif'
current_site_weight <- './data/GIS/site_flowlength/weighted/dadd_weight.tif'

wbt_downslope_flowpath_length(
    d8_pntr = current_site_dir,
    output = current_site_flowpath,
    weights = current_site_weight,
    watersheds = current_site_lidar)


dadd_X <- rast(current_site_flowpath)


dadd_ddn <- ifel(dadd_X == 0, 
                 dadd_inv_cs + dadd_X,
                 dadd_X)

# D up for Cmean and Smean is done in arc gis pro
# whitebox cannot weight flow accumulation





```


