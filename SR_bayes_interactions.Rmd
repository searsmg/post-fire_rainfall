---
title: "Post-fire stream response interactions"
author: "Megan Sears"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: yes
    theme: journal
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = F,
  message = F, 
  warning  = F)

library(pacman)

p_load(tidyverse, 
       reshape, 
       broom, 
       car, 
       ggdist, 
       brms, 
       rstanarm, 
       bayesplot, 
       performance,
       knitr,
       here)

# Set a basic ggplot theme
theme_set(theme_bw(base_size = 20))

```

```{r, include = F}

response <- read_csv('./data/final_model_inputs/events_inputs_v2.csv') %>%
  select(site,
         sp_cat, # categorical
         fire, # categorical
         stage_rise_cm,
         lag2peak_halfP,
         lag2peak_Pstart,
         MI60_mmhr,
         lag_pwd,
         terrain_hypso75 = hypso75,
         terrain_hypso25 = hypso25,
         terrain_hypso50 = hypso50,
         terrain_connec = IC,
         terrain_conn_dnbr = hydraulic_func_conn,
         area_km2 = area_km2.x,
         terrain_rc_circle = RC_CIRCLE.x,
         terrain_slope40 = slope40_frac,
         soil_brockdepmin = brockdepmin,
         terrain_recharge = frac_recharge_area,
         #terrain_vbw = avg_vbw_m,
         soil_sand = AVG_SAND,
         mean_dnbr, 
         soil_clay = AVG_CLAY,
         soil_ksat = AVG_KSAT, 
         terrain_elongation = ELONGATION.x, 
         soil_availwaterstor = aws0150wta, 
         NDVI, 
         terrain_vall_holl = frac_valley,
         terrain_flowlength = flow_length_m, 
         terrain_slope30 = slope30_frac, 
         SP_mean,
         terrain_hypsoint = hypso_integral,
         year,
         terrain_glacial = frac_glacial,
         fire_no,
         mulch_frac) %>%
  mutate(site_number = as.integer(factor(site))) %>% # give each site a number
  select(-site)

stage <- response %>%
  select(-c(lag2peak_halfP, 
            lag2peak_Pstart,
            fire_no)) %>% # remove lag to peak
  relocate(year, .after = site_number) %>% # move year to end of data set to make next line easier to code
  mutate(across(c(MI60_mmhr:mulch_frac), scale), # scale predictor data to mean = 0, sd =1
         site_number = factor(site_number),
         yearFact = factor(year), # year factor for random effect
         yearCont = year - 2022) # centered year for fixed effect

# will need to redo the above for lag to peak response var eventually

```

# Connectivity

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

# # include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*terrain_connec + 
#     fire + 
#     sp_cat + 
#     yearCont +     
#     (1 + MI60_mmhr | site_number) + 
#     (1|yearFact),                          
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

# saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_connec.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_connec.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, terrain_connec, MI60_mmhr.terrain_connec) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'terrain_connec'
var_title <- "Connectivity"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Clay

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

# # include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*soil_clay +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_clay.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_clay.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, soil_clay, MI60_mmhr.soil_clay) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'soil_clay'
var_title <- "Clay"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Fraction of slopes > 30

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

# # include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*terrain_slope30 +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_slope30.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_slope30.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, terrain_slope30, MI60_mmhr.terrain_slope30) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'terrain_slope30'
var_title <- "Slope 30"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Fraction of valleys & hollows

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

# include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*terrain_vall_holl +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_valleyhollows.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_valleyhollows.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr,terrain_vall_holl, MI60_mmhr.terrain_vall_holl) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'terrain_vall_holl'
var_title <- "Valleys & hollows"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# dNBR

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

# include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*mean_dnbr +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_dnbr.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_dnbr.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, mean_dnbr, MI60_mmhr.mean_dnbr) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'mean_dnbr'
var_title <- "Mean dNBR"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Elongation

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

# include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*terrain_elongation +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_elong.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_elong.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, terrain_elongation, MI60_mmhr.terrain_elongation) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'terrain_elongation'
var_title <- "Elongation"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Fraction of recharge areas

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

# #include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*terrain_recharge +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_recharge.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_recharge.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, terrain_recharge, MI60_mmhr.terrain_recharge) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'terrain_recharge'
var_title <- "Recharge areas"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Fraction of glacial areas

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

#include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*terrain_glacial +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_glacial.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_glacial.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, terrain_glacial, MI60_mmhr.terrain_glacial) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'terrain_glacial'
var_title <- "Glacial areas"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}
# do 0 or non zero 
nsData <- response %>%
  mutate(
    bin = if_else(.data[[var]] == 0, "Zero", "Non-zero")
  )

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```


# Snow persistence

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

#include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*SP_mean +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_sp.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_sp.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, SP_mean, MI60_mmhr.SP_mean) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'SP_mean'
var_title <- "Snow persistence"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Hypso75

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

#include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*terrain_hypso75 +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_hypso75.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_hypso75.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, terrain_hypso75, MI60_mmhr.terrain_hypso75) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'terrain_hypso75'
var_title <- "Hypso75"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Ksat

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

#include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*soil_ksat +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_ksat.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_ksat.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, soil_ksat, MI60_mmhr.soil_ksat) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'soil_ksat'
var_title <- "Ksat"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Flow length

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

#include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*terrain_flowlength +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_flowlength.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_flowlength.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, terrain_flowlength, MI60_mmhr.terrain_flowlength) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'terrain_flowlength'
var_title <- "Flow length"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

# Fraction of mulch

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

#include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*mulch_frac +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

#saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_mulch.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_mulch.rds"))

# already checked from above model & good
#summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, mulch_frac, MI60_mmhr.mulch_frac) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'mulch_frac'
var_title <- "Mulch fraction"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# do 0 or non zero 
nsData <- response %>%
  mutate(
    bin = if_else(.data[[var]] == 0, "Zero", "Non-zero")
  )

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)


```

# PWD

## Interaction

Model output

```{r, fig.width=12, fig.height=10}

# include linear interactions with static watershed characteristics
# interaction <- stan_glmer(
#   stage_rise_cm ~ MI60_mmhr*lag_pwd +
#     fire +
#     sp_cat +
#     yearCont +
#     (1 + MI60_mmhr | site_number) +
#     (1|yearFact),
#   data = stage,
#   family = Gamma(link = "log"),
#   prior = normal(0, 1),
#   prior_intercept = normal(0, 1),
#   prior_covariance = decov(regularization = 2),
#   chains = 3,
#   cores = 8,
#   iter = 3000,
#   adapt_delta = 0.99,
#   init = 0
# )

# saveRDS(interaction, "./data/bayes_interaction_outputs/interaction_pwd.rds")
# from the model above - need to update chains and iter 
interaction <- readRDS(here("./data/bayes_interaction_outputs/interaction_pwd.rds"))

# already checked from above model & good
summary(interaction)
check_model(interaction)

# get r2 for marginal and conditional
r2Vals <- r2(interaction)
r2_df <- data.frame(r2Vals)
knitr::kable(r2_df, caption = "Conditional and Marginal R2")


```

Posterior draws

```{r, fig.width=12, fig.height=10}

as_draws(interaction) %>% 
  data.frame() %>%
  select(MI60_mmhr, lag_pwd, MI60_mmhr.lag_pwd) %>%
  melt() %>%
  ggplot(., aes(x = value, fill = variable)) + theme_bw(base_size = 20) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = after_stat(level)), .width = c(.66, .95, 1), color = 'gray50') +
  stat_pointinterval(.width = c(.66, .95, 1), fatten_point = 2.5, color = 'darkred', interval_size_domain = c(2,5,10)) +
  paletteer::scale_fill_paletteer_d("soilpalettes::gley") +
  facet_wrap(~variable, ncol = 1) +
  theme(legend.position = 'none')

```

## Conditional effects

```{r, fig.width=12, fig.height=10}

var <- 'lag_pwd'
var_title <- "PWD"

mi60levels <- quantile(stage$MI60_mmhr,
                       probs = c(.05, .5, .95), 
                       na.rm = T) # group MI60 into 10, 50, and 90th percentile

terrainLevels <- quantile(stage[[var]], 
                          probs = c(.1, .5, .9), # get groups for catchment var
                          na.rm = T)

newData <- expand.grid(
  var = seq(min(stage[[var]]), max(stage[[var]]), length.out = 50),
  MI60_mmhr = mi60levels,
  yearCont = 0,
  sp_cat = c('low', 'high'),
  fire = c('cpf', 'etf'))

# rename the var column to the above
names(newData)[names(newData) == "var"] <- var

# predict out model output over expanded grid of data
predict <- posterior_linpred(interaction, 
                             newdata = newData, 
                             re.form = NA) 

# estimate model predicted mean for each level of mi60 plus 90% credible interval
predSummar <- apply(predict, 2, function(x) { 
  c(
    mean = mean(x),
    lower = quantile(x, 0.10),
    upper = quantile(x, 0.90)
  )
})


predictDF <- cbind(newData, t(predSummar)) %>%
  mutate(MI60 = factor(MI60_mmhr, 
                       labels = c("Low", "Mean", "High"))) %>%
  dplyr::rename(lower = `lower.10%`,
                upper = `upper.90%`)

# show low, med, high groups
ggplot(predictDF, 
       aes(x = .data[[var]], 
                      y = mean, 
           color = MI60, 
           fill = MI60)) +
  geom_line(size = 2) +
  geom_ribbon(aes(ymin = lower, 
                  ymax = upper), 
              alpha = 0.4, 
              color = NA) +
  labs(x = var_title, 
       y = 'Stage Rise',
       color = 'MI60', 
       fill = 'MI60') +
  paletteer::scale_fill_paletteer_d("ggthemes::wsj_dem_rep") +
  paletteer::scale_color_paletteer_d("ggthemes::wsj_dem_rep") +
  theme_bw(base_size = 25) +
  facet_grid(sp_cat ~ fire)

```

## Raw data

```{r, fig.width=12, fig.height=10}

# low, med, high bins for catchment var
nsData <- response %>%
  mutate(bin = cut(.data[[var]], 
                        breaks = quantile(.data[[var]], 
                                          probs = seq(0, 1, length.out = 4), 
                                          na.rm = TRUE),
                        include.lowest = TRUE,
                        labels = c("Low", "Medium", "High")))

# scatter plot
ggplot(nsData, aes(x = MI60_mmhr, 
                   y = stage_rise_cm, 
                   fill = bin, 
                   color = bin)) + 
  theme_bw(base_size = 25) +
  geom_point(shape = 21, size = 5) + 
  geom_smooth(method = 'lm') +
  labs(fill = var_title, 
       color = var_title) +
  theme(legend.position = c(0.7, 0.8))

# boxplot
nsData %>%
  mutate(bin = cut(.data[[var]], 
                   breaks = 5)) %>%
  ggplot(., aes(x = bin, 
                y = MI60_mmhr, 
                fill = bin)) + 
  geom_boxplot() +
  labs(fill = var_title)

```

